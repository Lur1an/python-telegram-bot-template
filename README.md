# ðŸš§ WORK IN PROGRESS, COOKING UP COOL STUFF...ðŸš§

I will start migrating a lot of utility functions into https://github.com/Lur1an/ptb-ext in the coming weeks to debloat the template, some of the docs below are probably outdated and will be moved gradually to the `ptb-ext` repo.

Also started working on setting up a good base for persistence using a typical SQL stack with `alembic + SQLAlchemy + SQLite`,

# python-telegram-bot-template

This repository serves as a template to create
new [python-telegram-bot](https://github.com/python-telegram-bot/python-telegram-bot)
applications, their python wrapper over the Telegram API is amazing and enables very smooth programming for bots. It
doesn't however provide **_defaults_** for persistence, state management and other shortcuts that are necessary for a
maintainable and growable software architecture.

This template is mostly meant for projects that start with quite a bit of complexity and whose requirements are going to
evolve as time passes.

### Please read!

The documentation from this point forward may be incorrect, I did some refactoring for a few wrapper and edited a few typings as my new LSP gave me a lot of errors (went from Pycharm to Pyright).
I will update this documentation in the future.

### Foreword

I made this template to provide an implementation for a few things that I always ended up implementing in my _telegram
bot_ projects, custom `ApplicationContext` for `context.bot_data, context.chat_data, context.user_data` typing,
decorators/wrappers for handlers to cut down on a bit of boilerplate and implement common behaviours. This will take the
mind off technicalities and instead help put your focus where it belongs, on the project.

### Run the Bot

- Make sure [poetry](https://python-poetry.org) is installed on your system.
- Run: `poetry install`

The bot can be run in either `production` or `dev` mode. The difference being that the `dev` mode loads your environment variables
from the `.env` file in the project and does a complete teardown + buildup of your database to give you a fresh debugging environment every time.

#### Dev mode

- Run: `poetry run python -m src.main --dev` or execute the `main` function in your debugger which will default to `dev` mode. (make sure the environment is activated by running `poetry shell` first)

#### Production mode

Production mode runs alembic migrations against your database before starting the bot, make sure the following environment variables are set:

- `BOT_TOKEN` you can get one from **_[Botfather](https://t.me/botfather)_**
- `DB_PATH` the path to your database, relative from where the bot is executing. (I recommend choosing `/data/yourdb.sqlite3`, as a `/data` directory is automatically created in the Docker container and can be mounted to a persistent volume)

Finally:

- Execute `./entrypoint.sh`

### DB Migrations

Now that the template is running on SQL, every time your schema changes you will need to run new migrations on your production database to keep up to date. `env.py` is already set up to read `DB_PATH` env variable or default to the `db.sqlite3` file.

Define your database schema inside of `db/tables.py`, then to autogenerate the migration run: `alembic revision --autogenerate -m "<description>"`, the migrations
are then applied whenever the application starts through `entrypoint.sh`.

#### Example

Lets define a `User` table inside of `tables.py`:

```python
from sqlalchemy.orm import Mapped, declarative_base, mapped_column
Base = declarative_base()

class User(Base):
    __tablename__ = "users"
    id: Mapped[int] = mapped_column(primary_key=True)
    telegram_id: Mapped[int] = mapped_column(unique=True, nullable=False)
    is_bot: Mapped[bool] = mapped_column(nullable=False)
    telegram_username: Mapped[str] = mapped_column(nullable=True)
    """
    Can be hidden due to privacy settings
    """
```

Now lets run `alembic revision --autogenerate -m "user table"`, a wild `247a9e59a9a8_user_table.py` just appeared!!

```python
"""
user table

Revision ID: 247a9e59a9a8
Revises:
Create Date: 2023-11-26 10:03:21.771222

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '247a9e59a9a8'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('telegram_id', sa.Integer(), nullable=False),
    sa.Column('is_bot', sa.Boolean(), nullable=False),
    sa.Column('telegram_username', sa.String(), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('telegram_id')
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('users')
    # ### end Alembic commands ###
```

This file contains SQLAlchemy commands to update the schema in your database! You can also add your own custom commands if you feel like it because the ORM does not fullfill all your needs, here is an example how I added a trigger in one of my projects:

- Run: `alembic revision -m "create trigger for product cleanup"`
- Inside of the `upgrade` function in the generated file add your SQL:

```python
def upgrade() -> None:
    op.execute(
        """
        DELETE FROM products
        WHERE NOT EXISTS (
            SELECT 1 FROM alerts
            WHERE alerts.product_id = products.id
        );
        """
    )
    op.execute(
        """
    CREATE TRIGGER DeleteProductsWithNoAlerts
    AFTER DELETE ON alerts
    BEGIN
      DELETE FROM products
      WHERE id = OLD.product_id
        AND NOT EXISTS (
          SELECT 1 FROM alerts
          WHERE alerts.product_id = OLD.product_id
        );
    END;
    """
    )
```

- Inside of the `downgrade` function add the code necessary to get back to the previous schema

```python
def downgrade() -> None:
    op.execute("""DROP TRIGGER IF EXISTS DeleteProductsWithNoAlerts;""")
```

The Specific SQL shown in the example is out of scope of this template, but this should showcase how you can tweak the database to your liking!

### Devops and Dependency management

This project comes with a barebone CI pipeline.

1. It tests your code using pytest, the same as it would locally with `poetry run python -m pytest`
2. It builds the Docker image
3. It pushes the Docker image to a repository, just open up `ci.yml` and fill out the secrets in your own repository

### Configuration

The app gets its configuration from environment variables that are defined in the classes
extending `pydantic.BaseSettings` in `settings.py`

```python
from pydantic_settings import BaseSettings

class DBSettings(BaseSettings):
    DB_PATH: str = "template_app.db"

class TelegramSettings(BaseSettings):
    BOT_TOKEN: str


class Settings(TelegramSettings, DBSettings):
    pass


settings = Settings()

```

### Application State

When you use python-telegram-bot you have access to 3 shared objects on your `context`:

1. `context.user_data`, this object is shared between all handlers that interact with updates from the same user
2. `context.chat_data`, shared between all updates for the same chat
3. `context.bot_data`, this is shared by all handlers and is useful to keep track of your shared application state

Working with raw dicts is error prone, that's why python-telegram-bot let's you define your own `CallbackContext` to
replace the usual `ContextTypes.DEFAULT`.
The boilerplate needed for your `ContextTypes` is already set up inside of `src/bot/common/context.py`

```python
class BotData:
    pass

class ChatData:
    pass

class UserData:
    pass

class ApplicationContext(CallbackContext[ExtBot, UserData, ChatData, BotData]):
    # Define custom @property and utility methods here that interact with your context
    pass
```

You will find these classes in the `bot.common` module in `context.py`, you can edit the three classes above to define
the state in your application depending on the context, the `ApplicationContext` class itself is used in the type signature for the context of your handlers and you can also define useful `@property` and other utility methods on it as well.

#### How are my Context classes initialized if I am only passing them as type-hints?

To make the framework instantiate your custom objects instead of the usual dictionaries they are passed as
a `ContextTypes` object to your `ApplicationBuilder`, the template takes care of this. The `Application` object itself
is build inside of `bot.application`, that's also where you will need to register your handlers, either in the `on_startup` method or on the application object.

```python
context_types = ContextTypes(
    context=ApplicationContext,
    chat_data=ChatData,
    bot_data=BotData,
    user_data=UserData
)

application: Application = (
    ApplicationBuilder()
    .token(settings.BOT_TOKEN)
    .context_types(context_types)
    .arbitrary_callback_data(True)
    .post_init(on_startup)
    .build()
)
```

### Conversation State

As you may have noticed, the three State objects that are present in the context have user, chat and global scope. A lot
of logic is implemented inside of `ConversationHandler` flows and for this custom state-management is needed, usually
inside either `chat_data` or `user_data`, as most of these flows in my experience have been on a per-user basis I have
provided a default to achieve this without having to add a new field to your `UserData` class for every
conversation-flow that you need to implement.

```python
class UserData:
    _conversation_state: Dict[Type[ConversationState], ConversationState] = {}

    def get_conversation_state(self, cls: Type[ConversationState]) -> ConversationState:
        return self._conversation_state[cls]

    def initialize_conversation_state(self, cls: Type[ConversationState]):
        self._conversation_state[cls] = cls()

    def clean_up_conversation_state(self, conversation_type: Type[ConversationState]):
        del self._conversation_state[conversation_type]
```

The `UserData` class comes pre-defined with a dictionary to hold conversation state, the type of the object
itself is used as a key to identify it, this necessitates that for a conversation state type `T` there is at most 1
active conversation **_per user_** that uses this type for its state.

To avoid leaking memory this object needs to be cleared from the dictionary when you are done with it, to take care of
initialization and cleanup I have created three decorators:

```python
def init_stateful_conversation(conversation_state_type: Type[ConversationState]):
    ...


def inject_conversation_state(conversation_state_type: Type[ConversationState]):
    ...


def cleanup_stateful_conversation(conversation_state_type: Type[ConversationState]):
    ...
```

Using these you can decorate your conversation entry/exit points, to take care of the state and also inject the object
into your function as an argument. `cleanup_stateful_conversation` also makes sure to catch any unexpected exceptions
and return `Conversation handler.END` when it finishes.

For example, let's define an entry point handler and an exit method for a conversation flow where a user needs to follow
multiple steps to fill up a `OrderRequest` object. (I will ignore the implementation details for
a `ConversationHandler`, if you want to see a good example of how this works
**_[click here](https://docs.python-telegram-bot.org/en/stable/examples.conversationbot.html)_**)

```python
@init_stateful_conversation(OrderRequest)
async def start_order_request(
        update: Update,
        context: ApplicationContext,
        order_request: OrderRequest
):
    ...


@inject_conversation_state(OrderRequest)
async def add_item(
        update: Update,
        context: ApplicationContext,
        order_request: OrderRequest
):
    ...


@cleanup_stateful_conversation(OrderRequest)
async def file_order(
        update: Update,
        context: ApplicationContext,
        order_request: OrderRequest
):
    # Complete the order, persist to database, send messages, etc...
    ...
```

### Utility decorators

```python
def restricted_action(is_allowed: Callable[[Update, ApplicationContext], Awaitable[Any]]):
    def inner_decorator(f: Callable[[Update, ApplicationContext], Awaitable[Any]]):
        @wraps(f)
        async def wrapped(update: Update, context: ApplicationContext):
            if await is_allowed(update, context):
                return await f(update, context)

        return wrapped

    return inner_decorator
```

This decorator is used to restrict handler access by using the function passed as parameter to the decorator to check.

```python
def delete_message_after(f: Callable[[Update, ApplicationContext], Awaitable[Any]]):
    @wraps(f)
    async def wrapper(update: Update, context: ApplicationContext):
        result = await f(update, context)
        try:
            await context.bot.delete_message(
                message_id=update.effective_message.id,
                chat_id=update.effective_chat.id
            )
        finally:
            return result

    return wrapper
```

This decorator ensures your handler **_tries_** to delete the message after finishing the
logic, `update.effective_message.delete()` from time to time throws exceptions even when it shouldn't, as
does `bot.delete_message`, this decorator is a easy and safe way to abstract this away and make sure you tried your best
to delete that message.

```python
def exit_conversation_on_exception(
        _f: Callable[[Update, ApplicationContext], Any] = None, *,
        user_message: str = "I'm sorry, something went wrong, try again or contact an Administrator."
):
    def inner_decorator(f: Callable[[Update, ApplicationContext], Any]):
        @wraps(f)
        async def wrapped(update: Update, context: ApplicationContext):
            try:
                return await f(update, context)
            except Exception as e:
                log.error(f"Encountered an error while handling conversation step: {e}")
                await context.bot.send_message(
                    chat_id=update.effective_chat.id,
                    text=user_message
                )
                context.chat_data.conversation_data = None
                return ConversationHandler.END

        return wrapped

    if _f is None:
        return inner_decorator
    else:
        return inner_decorator(_f)
```

This decorator catches any unchecked exceptions in your handlers inside of your conversation flow that you annotate with
it and sends the poor user that had to interact with your **_(my)_** mess a message.

### CallbackQuery data injection

Arbitrary callback data is an awesome feature of _python-telegram-bot_, it increases security of your application (
callback-queries are generated on the client-side and can contain malicious payloads) and makes your development
workflow easier.

Since the smoothest interactions are through inline keyboards your application will be full of `CallbackQueryHandler`
flows. The problem is that `callback_data` does not provide a type hint for your objects, making you write the same code
over and over again to satisfy the type checker and get type hints:

```python
async def sample_handler(update: Update, context: ApplicationContext):
    my_data = cast(CustomData, context.callback_data)
    ...  # do stuff
    await update.callback_query.answer()
    # if you want you can also clear your callback data from your cache
```

I prefer using my decorator:

```python
def inject_callback_query(
        _f: Callable[[Update, ApplicationContext, CallbackDataType], Awaitable[Any]] = None, *,
        answer_query_after: bool = True,
        clear_callback_data: bool = False,
):
    def inner_decorator(f: Callable[[Update, ApplicationContext, CallbackDataType], Awaitable[Any]]):
        @wraps(f)
        async def wrapped(update: Update, context: ApplicationContext):
            converted_data = cast(CallbackDataType, update.callback_query.data)
            result = await f(update, context, converted_data)
            if answer_query_after:
                try:
                    await update.callback_query.answer()
                except Exception as e:
                    log.error(f"Failed answering callback_query: {e}")
            if clear_callback_data:
                try:
                    context.drop_callback_data(update.callback_query)
                except KeyError as e:
                    log.error(f"Failed dropping callback_query_data, couldn't find Key: {e}")

            return result

        return wrapped

    if _f is None:
        return inner_decorator
    else:
        return inner_decorator(_f)
```

Now you can write your handler like this:

```python
@inject_callback_query
async def sample_handler(update: Update, context: ApplicationContext, my_data: CustomData):
    ...  # do stuff
```

Since we are interacting with our `CustomData` type in our `CallbackQueryHandler` most of the time we only have 1
handler for this defined Callback Type and always end up writing:

```python
custom_data_callback_handler = CallbackQueryHandler(callback=sample_handler, pattern=CustomData)
```

I added another decorator to turn the wrapped function directly into a `CallbackQueryHandler`:

```python
def arbitrary_callback_query_handler(
        query_data_type: CallbackDataType, *,
        inject: bool = True,
        answer_query_after: bool = True,
        clear_callback_data: bool = False
):
    if inject:
        def inner_decorator(
                f: Callable[[Update, ApplicationContext, CallbackDataType], Awaitable[Any]]
        ) -> CallbackQueryHandler:
            decorator = inject_callback_query(
                answer_query_after=answer_query_after,
                clear_callback_data=clear_callback_data
            )
            wrapped = decorator(f)
            handler = CallbackQueryHandler(pattern=query_data_type, callback=wrapped)
            return handler

        return inner_decorator
    else:
        def inner_decorator(
                f: Callable[[Update, ApplicationContext], Awaitable[Any]]
        ) -> CallbackQueryHandler:
            if answer_query_after:
                f = answer_inline_query_after(f)
            if clear_callback_data:
                f = drop_callback_data_after(f)
            handler = CallbackQueryHandler(pattern=query_data_type, callback=f)
            return handler

        return inner_decorator

```

This will take care of instantiating your `CallbackQueryHandler`, putting this together with the above sample we can
write it like this:

```python
@arbitrary_callback_query_handler(CustomData)
async def sample_handler(update: Update, context: ApplicationContext, my_data: CustomData):
    ...  # do stuff
```

Keep in mind that this approach is a bit limited if you want to handle types of `CustomData` callback queries
differently depending on other patterns like chat or message content, python-telegram-bot lets you combine patterns
together with binary logic operators, as I have rarely used this I have not added parameters to the decorator for this
case, I might in the future. Since this is just a template you can also do it yourself for your project!

### Project Structure

I would recommend you keep your code loosely coupled and keep cohesion high, separate your modules by feature:

```
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ bot
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ application.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ common
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ context.py
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ wrappers.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”œâ”€â”€ orders
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ conversations
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â â”œâ”€â”€ create_order.py
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â â”œâ”€â”€ edit_order.py
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ persistence.py
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ models.py
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ handlers.py
â”‚Â Â  â”œâ”€â”€ db
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ config.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ core.py
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ encoders.py
â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”œâ”€â”€ main.py
â”‚Â Â  â”œâ”€â”€ resources
â”‚Â Â  â””â”€â”€ settings.py
â””â”€â”€ tests
â””â”€â”€ __init__.py
```

I added a folder `orders` that could represent a way to add a feature to interact with orders:

- `persistence.py` can contain your class `OrderDAO` and `OrderEntity` to model your database persistence
- `models.py` can contain other object types you need, like classes for custom callback queries or conversation state
- `handlers.py` is where you define the handlers needed to interact with this module through the telegram api, export a
  list of handlers that you import in `application.py` and then add to the `Application` object
  through `add_handlers()`. This list of handlers has to contain all the handlers of the module
- `conversations` contains a file for every `ConversationHandler` the module defines, since it takes a lot of code to
  define a single conversation, with it's states, state-management, fallbacks etc. a single file for every conversation
  flow seems okay.

These are just examples how the structure could look like.

### Cool wrappers

```python
def command_handler(command: str, *, allow_group: bool = False):
    def inner_decorator(f: Callable[[Update, ApplicationContext], Coroutine[Any, Any, RT]]) -> CommandHandler:
        return CommandHandler(
            filters=None if allow_group else filters.ChatType.PRIVATE,
            command=command,
            callback=f
        )

    return inner_decorator
```

Shortcut to create command handlers, by default they are set to only work in private chats and have to be explicitly
activated for group chats.

```python
def load_user(
        _f: Callable[[Update, ApplicationContext, User], Coroutine[Any, Any, RT]] = None,
        *,
        required: bool = False,
        error_message: Optional[str] = None
):
    def inner_decorator(f: Callable[[Update, ApplicationContext, User], Coroutine[Any, Any, RT]]):
        @wraps(f)
        async def wrapped(update: Update, context: ApplicationContext):
            user = context.get_cached_user(update.effective_user.id)
            if user is None:
                dao = UserDAO(db)
                user = await dao.find_by_telegram_id(update.effective_user.id)
            if user is None and required:
                if error_message is not None:
                    await context.bot.send_message(
                        chat_id=update.effective_chat.id,
                        text=error_message
                    )
                return
            if user is not None:
                context.cache_user(user)
            return await f(update, context, user)

        return wrapped

    if _f is None:
        return inner_decorator
    else:
        return inner_decorator(_f)
```

This decorator allows you to pre-load the user before actually handling the event and avoids the usual 'check in
cache' -> 'load from database' flow, and if user is not found and you want to send a default error message you can also
set this from the decorator.

### Reducing boilerplate for [user <-> data] interactions

After programming bots for a while I always found myself using the same pattern to define actions on my entities:

```python
class DeleteItem(BaseModel):
    item: Item


delete_item_button = InlineKeyboardButton(
    text="âŒ DELETE ITEM âŒ",
    callback_data=DeleteItem(item=my_item)
)
reply_markup = InlineKeyboardMarkup([
    [delete_item_button]
])
```

This would create a menu with a single button, but you can imagine that there could be more, each one with its own class
for the action it represents. So I came up with this class that turns itself into a button or a single keyboard (found
myself often making single-row keyboards), I reference `__class__.__name__` to derive the button text and surround it
with an emoji if provided, turning a class like `EDIT_ITEM` into either `EDIT` or `EDIT ITEM` buttons.

```python
class CallbackButton(BaseModel):
    def to_short_button(self, *, emoji: Optional[str] = None) -> InlineKeyboardButton:
        text = self.__class__.__name__.split("_")[0]
        if emoji:
            text = f"{emoji} {text} {emoji}"
        return InlineKeyboardButton(text=text, callback_data=self)

    def to_button(self, *, text: Optional[str] = None, emoji: Optional[str]) -> InlineKeyboardButton:
        if text is None:
            text = (' ').join(self.__class__.__name__.split("_"))

        if emoji:
            text = f"{emoji} {text} {emoji}"
        return InlineKeyboardButton(text=text, callback_data=self)

    def to_keyboard(
            self,
            *,
            text: Optional[str] = None,
            emoji: Optional[str] = None
    ) -> InlineKeyboardMarkup:
        return InlineKeyboardMarkup([
            [self.to_button(text=text, emoji=emoji)]
        ])
```

Now we can rewrite the block before as:

```python
class DELETE_ITEM(CallbackButton):
    item: Item


reply_markup = DELETE_ITEM(item=item).to_keyboard()
```

Now that we have an action we would define it's `CallbackQueryHandler` using the decorator I showed before:

```python
@arbitrary_callback_query_handler(DELETE_ITEM)
async def delete_item(update: Update, context: ApplicationContext, action: DELETE_ITEM):
    ...
```
